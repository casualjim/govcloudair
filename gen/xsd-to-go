#!/usr/bin/env ruby

# Copyright (c) 2014 VMware, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This does not generate working code, but it does get you 90% of the way there.
# You should review the generated code VERY carefully and make sure that the types match up.
# Since this generates go there are certain things that will trigger compilation failures.
#
# The xsd's that are used for doing the code generation sometimes don't even generate correct java.
# So make sure you double and triple check the code that was generated, and make the necessary edits.
#
# Luckily most of the things that are generated don't change for years, some of these got their last update back
# in 2009 so it's not like you'll be doing these manual edits daily or even monthly.

$:.unshift(File.expand_path(File.dirname(__FILE__)))

require 'set'
require 'nokogiri'
require 'erb'
require 'active_support/inflector'

SCHEMA_PATH = File.join(File.expand_path(File.dirname(__FILE__)), "..", "schemas")
DEFAULT_GO_TYPES = {
  "xs:boolean"          => "bool",
  "xs:string"           => "string",
  "xs:normalizedString" => "string",
  "xs:token"            => "string",
  "xs:anyURI"           => "*url.URL",
  "xs:byte"             => "int8",
  "xs:short"            => "int16",
  "xs:int"              => "int32",
  "xs:integer"          => "int",
  "xs:long"             => "int64",
  "xs:float"            => "float32",
  "xs:double"           => "float64",
  "xs:decimal"          => "float64",
  "xs:unsignedLong"     => "uint64",
  "xs:unsignedInt"      => "uint32",
  "xs:unsignedShort"    => "uint16",
  "xs:unsignedByte"     => "uint8",
  "xs:date"             => "time.Time",
  "xs:base64Binary"     => "[]byte",
  "xs:hexBinary"        => "[]byte",
}
COMMON_GO_CAPS = {
  "API"   => true,
  "ASCII" => true,
  "CPU"   => true,
  "CSS"   => true,
  "DNS"   => true,
  "EOF"   => true,
  "GUID"  => true,
  "HREF"  => true,
  "HTML"  => true,
  "HTTP"  => true,
  "HTTPS" => true,
  "ID"    => true,
  "IP"    => true,
  "JSON"  => true,
  "LHS"   => true,
  "QPS"   => true,
  "RAM"   => true,
  "RHS"   => true,
  "RPC"   => true,
  "SLA"   => true,
  "SMTP"  => true,
  "SQL"   => true,
  "SSH"   => true,
  "TCP"   => true,
  "TLS"   => true,
  "TTL"   => true,
  "UDP"   => true,
  "UI"    => true,
  "UID"   => true,
  "UUID"  => true,
  "URI"   => true,
  "URL"   => true,
  "UTF8"  => true,
  "VM"    => true,
  "XML"   => true,
  "XSRF"  => true,
  "XSS"   => true
}

REFINE_TEMPLATE = <<REFINE
type <%= go_name %><% if enum? %>Enum<% end %> <%= go_type %><% if validatable? %>

func (v <%= go_name %>) Validate(name string) error {
  <% if min_length %>if len(v) < <%= min_length %>{
    return fmt.Errorf("%q should be at least <%= min_length %> chars", name)
  }<% end %><% if max_length %>if len(v) > <%= max_length %>{
    return fmt.Errorf("%q should be at most <%= max_length %> chars", name)
  }<% end %>
}
<% end %>
<% unless (values||[]).empty? %>
var (
<% values.each do |val| %>
  <%= val.classify %><%= go_name %> = <%= go_name %>Enum("<%= val %>")<% end %>
)
<% end %>
REFINE

STRUCT_TEMPLATE = <<STRUCT
/* A <%= name %> <%= doc.text if doc %><% if doc and doc.since %>
since: <%= doc.since %><% end %>*/
type <%= go_name %> struct {
  <% (ancestors||[]).each do |anc| %><%= anc %>
  <% end %>

  <% (properties||[]).each do |prop| %><% if prop.doc and prop.doc.text %>/*<%= prop.doc.text %>
  <% end %><%= prop.go_name %> <% if prop.slice? %>[]<% end %><%= prop.go_type %> `xml:"<%= prop.name %><%= prop.attribute? ? ",attr" : "" %><%= prop.optional? ? ",omitempty" : "" %>"`
  <% end %>
}

STRUCT

COMMON_GO_CAPS.keys.each do |vl|
  ActiveSupport::Inflector.inflections do |inf|
    inf.acronym vl
  end
end

class SimpleType
  attr_accessor :type, :min_length, :max_length, :pattern, :values

  def initialize(*args)
    @node = args.first
    @node.elements.each(&method(:parse_element))
  end

  def parse_element(el)
    case el.name
    when "restriction"
      @type = el["base"]
      el.elements.each(&method(:parse_restrictions))
    when "annotation"
      # skipping docs for now
    end
  end

  def parse_restrictions(el)
    case el.name
    when "minLength"
      @min_length = el["value"]
    when "pattern"
      @pattern = el["value"]
    when "enumeration"
      (@values||=[]) << el["value"]
    end
  end

  def name
    @node["name"]
  end

  def to_s
    self.name
  end

  def go_type
    mapped = DEFAULT_GO_TYPES[self.type]
    return mapped if mapped
    self.type
  end

  def go_name
    self.name.classify
  end

  def to_go
    templ = ERB.new(REFINE_TEMPLATE)
    templ.run(binding)
  end

  def validatable?
    @min_length || @max_length || @pattern
  end

  def enum?
    !(@values||[]).empty?
  end

end

class TypeDocs
  attr_accessor :text, :since, :modifiable

  def modifiable?
    !!@modifiable
  end
end

class ComplexType
  attr_accessor :doc, :content_type, :properties, :ancestors

  def initialize(*args)
    @parent, @node = args[0], args[1]
    @node.elements.each(&method(:parse_element))
  end

  def parse_element(el)
    case el.name
    when "annotation"
      # check for doc comments
      el.elements.each(&method(:parse_annotation))
    when "element"
      (@properties||=[]) << Property.new(nil, el, false)
    when "sequence"
      el.elements.each_with_index(&method(:parse_sequence))
    when "attribute"
      (@properties||=[]) << Property.new(nil, el, true)
    when "complexContent"
      el.elements.each(&method(:parse_complex_content))
    when "simpleContent"
      el.elements.each(&method(:parse_simple_content))
    else
      puts "#{self.class} unknown element: #{el.to_xml}"
    end
  end

  def parse_simple_content(el)
      case el.name
      when "extension"
        el.elements.each(&method(:parse_element))
      else
        puts "#{self.class} simple content unknown element: #{el.to_xml}"
      end
  end

  def parse_sequence(el, i)
    case el.name
    when "element"
      (@properties||=[]) << Property.new(i, el, false)
    when "attribute"
      (@properties||=[]) << Property.new(i, el, true)
    when "annotation"
      el.elements.each(&method(:parse_annotation))
    when "sequence"
      el.elements.each_with_index(&method(:parse_sequence))
    when "complexContent"
      el.elements.each(&method(:parse_complex_content))
    end
  end

  def parse_complex_content(el)
    case el.name
    when "annotation"
      el.elements.each(&method(:parse_annotation))
    when "extension"
      (@ancestors||=[]) << el["base"].gsub(/[^:]+:/, "").classify
      el.elements.each(&method(:parse_element))
    else
      puts "#{self.class} complex content unknown element #{el.to_xml}"
    end
  end

  def parse_annotation(el)
    case el.name
    when "documentation"
      self.parse_documentation(el)
    when "appinfo"
      self.parse_appinfo(el)
    end
  end

  def parse_documentation(at)
    case at["source"]
    when "since", "added-in"
      (@doc||=TypeDocs.new).since = at.text
    when "modifiable"
      (@doc||=TypeDocs.new).modifiable = at.text
    when "deprecated", "internal"
    else
      # only if the docs are english, we're interested
      if at["xml:lang"] == "en" or at.attributes.empty?
        (@doc||=TypeDocs.new).text = at.text
      else
        puts "#{self.class} documentation unknown element: #{at.to_xml}"
      end
    end
  end

  def parse_appinfo(apinf)
    apinf.elements.each do |el|
      if el.name == "content-type"
        @content_type = el.text
      end
    end
  end

  def name
    @node["name"]
  end

  def go_name
    self.name.classify
  end

  def type
    @node["type"].classify
  end


  def to_s
    self.name
  end

  def to_go
    templ = ERB.new(STRUCT_TEMPLATE)
    templ.run(binding)
  end

end

class Property
  attr_accessor :ordinal, :doc, :is_attribute

  def initialize(ord, node, iattr)
    @ordinal, @node, @is_attribute = ord, node, !!iattr
  end

  def parse_element(el)
    case el.name
    when "annotation"
      el.elements.each do |ann|
        if ann.name == "documentation"
          parse_documentation(ann)
        end
      end
    else
      puts "#{self.class} unknown element: #{el.to_xml}"
    end
  end

  def parse_documentation(at)
    case at["source"]
    when "since", "added-in"
      (@doc||=TypeDocs.new).since = at.text
    when "modifiable"
      (@doc||=TypeDocs.new).modifiable = at.text
    when "deprecated"
    else
      # only if the docs are english, we're interested
      if at["xml:lang"] == "en" or at.attributes.empty?
        (@doc||=TypeDocs.new).text = at.text
      else
        puts "unknown element: #{at.to_xml}"
      end
    end
  end

  def required?
    @node["use"] == "required" || (@node["minOccurs"] =~ /\d+/ && @node["minOccurs"].to_i == 0)
  end

  def optional?
    !self.required?
  end

  def attribute?
    @is_attribute
  end

  def slice?
    @node["maxOccurs"] == "unbounded" || (@node["maxOccurs"] =~ /\d+/ && @node["maxOccurs"].to_i > 1)
  end

  def type
    return @node["type"] if @node["type"]
    return @node["ref"].gsub(/[^:]+:/, "") if @node["ref"]
    puts @node.to_xml
    exit 1
  end

  def name
    @node["name"]||@node["ref"].gsub(/[^:]+:/, "")
  end

  def go_type
    mapped = DEFAULT_GO_TYPES[self.type]
    return mapped if mapped
    self.type.gsub(/[^:]+:/, "").classify
  end

  def go_name
    self.name.classify
  end

  def to_s
    "#{self.name} -> #{self.type}"
  end
end

class SchemaReader
  attr_accessor :path, :types, :included_schemas, :path_parts

  def initialize(*args)
    @path_parts = args
    @path = File.join(*args)
    puts "reading #{@path}"
    @types = []
    @included_schemas = { File.basename(@path) => self }
  end

  def parse()
    schema = Nokogiri(File.read(@path))
    schema.root.elements.each(&method(:parse_element))
  end

  def parse_element(el)
    case el.name
    when "complexType"
      @types << ComplexType.new(self, el)
    when "simpleType"
      @types << SimpleType.new(el)
    when "element"
      # in java this seems to be used to generate factory methods
      # luckily this isn't java
    when "include"
      loc = el["schemaLocation"]
      unless !loc or /^http/ =~ loc or @included_schemas.has_key? File.basename(loc)
        rdr = SchemaReader.new(File.dirname(@path), loc)
        rdr.included_schemas.merge! @included_schemas
        rdr.parse
        # flatten and lift the included schemas, so lookup is quick and easy
        @included_schemas.merge! rdr.included_schemas
      end
    when "annotation"
      #puts "skipping annotation at top level"
    when "attribute"
      # puts "skipping attribute at top level"
    when "import"
      loc = el["schemaLocation"]
      unless !loc or /^http/ =~ loc or @included_schemas.has_key? File.basename(loc)
        #path_parts = @path_parts.dup
        #path_parts[path_parts.size-1] = loc
        rdr = SchemaReader.new(File.dirname(@path), loc)
        rdr.included_schemas.merge! @included_schemas
        rdr.parse
        # flatten and lift the included schemas, so lookup is quick and easy
        @included_schemas.merge! rdr.included_schemas
      end
    else
      puts "#{self.class} unknown type #{el.name}"
    end
  end

  def has?(tpe)
    @types.any? do |tt|
      tt.name == tpe.to_s
    end
  end

  def size
    @types.size
  end
end


if $0 == __FILE__
  types = []

  ## parse the schemas
  #%w(base error service session vchs).each do |nm|
    #rdr = SchemaReader.new(SCHEMA_PATH, "vcloudair56", "#{nm}.xsd")
    #rdr.parse
    ##puts "collected #{rdr.size} types"
    ##puts rdr.types
    #types.concat rdr.types
    ##puts "reader has ServiceType: #{rdr.has?(:ServiceType)}"
    ##puts "included schemas: #{rdr.included_schemas.keys}"
  #end

  #types.each do |tpe|
    ##puts "#{tpe.name} has #{(tpe.properties||[]).size} properties and #{(tpe.ancestors||[]).size} ancestors"
    #tpe.to_go
  #end

  ##types.clear

  #{
    #"common"=>%w(simpleTypes complexTypes resource Meta),
    #"sc"=>%w(binding instance serviceplan),
    #"user"=> %w(User),
    #"" => %w(billableRates error metering)
  #}.each do |k, v|
    #v.each do |nm|
      #rdr = k ? SchemaReader.new(SCHEMA_PATH, "vcloudair57", k, "#{nm}.xsd") : SchemaReader.new(SCHEMA_PATH, "vcloudair57", "#{nm}.xsd")
      #rdr.parse
      #types.concat rdr.types
    #end
  #end

  #types.each do |tpe|
    #tpe.to_go
  #end

  #types.clear

  {
    #"admin" => %w(admin amqp blockingExtensions event providerVdc upload user vCloudEntities),
    #"extension" => %w(notification services settings taskExtensionRequest vmwextensions),
    #"master" => %w(master),
    #"networkservice" => %w(diagnostics entity ipam network),
    "vcloud" => %w(common catalog catalogItem disk entity file hybrid media metrics mksTicket organization organizationList productSectionList queryRecordView queryReferenceView resourceEntity screenTicket services session task tasksList vApp vAppTemplate vcloud vdc vdcStorageProfile vendorServices vms)
  }.each do |k, v|
    v.each do |nm|
      rdr = SchemaReader.new(SCHEMA_PATH, "vcloudair511/1.5/schemas", k, "#{nm}.xsd")
      rdr.parse
      types.concat rdr.types
    end
  end

  types.each do |tpe|
    tpe.to_go
  end
end
