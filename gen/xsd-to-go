#!/usr/bin/env ruby

# Copyright (c) 2014 VMware, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

$:.unshift(File.expand_path(File.dirname(__FILE__)))

require 'set'
require 'nokogiri'
require 'erb'
require 'active_support/inflector'

PRIMITIVES = %w(string byte bool int8 int16 int32 int64 int uint8 uint16 uint32 uint64 uint string float32 float64).to_set
API_VERSIONS = ["56", "57", "511"]
SCHEMA_PATH = File.join(File.expand_path(File.dirname(__FILE__)), "..", "schemas")
TYPE_MAPPING = {
  "xs:string" => "string",
  "xs:anyURI" => "*url.URL",
  "xs:int"    => "int32",
  "xs:long"   => "int64",
  "xs:date"   => "time.Time"
}
COMMON_GO_CAPS = {
  "API"   => true,
	"ASCII" => true,
	"CPU"   => true,
	"CSS"   => true,
	"DNS"   => true,
	"EOF"   => true,
	"GUID"  => true,
  "HREF"  => true,
	"HTML"  => true,
	"HTTP"  => true,
	"HTTPS" => true,
	"ID" =>    true,
	"IP" =>    true,
	"JSON" =>  true,
	"LHS" =>   true,
	"QPS" =>   true,
	"RAM" =>   true,
	"RHS" =>   true,
	"RPC" =>   true,
	"SLA"  =>   true,
	"SMTP" =>  true,
	"SQL" =>   true,
	"SSH" =>   true,
	"TCP" =>   true,
	"TLS" =>   true,
	"TTL" =>   true,
	"UDP" =>   true,
	"UI" =>    true,
	"UID" =>   true,
	"UUID" =>  true,
	"URI" =>   true,
	"URL" =>   true,
	"UTF8" =>  true,
	"VM" =>    true,
	"XML" =>   true,
	"XSRF" =>  true,
	"XSS" =>   true
}

REFINE_TEMPLATE = <<REFINE
type <%= go_name %> <%= go_type %><% if validatable? %>

func (v <%= go_name %>) Validate(name string) error {
  <% if min_length %>if len(v) < <%= min_length %>{
    return fmt.Errorf("%q should be at least <%= min_length %> chars", name)
  }<% end %><% if max_length %>if len(v) > <%= max_length %>{
    return fmt.Errorf("%q should be at most <%= max_length %> chars", name)
  }<% end %>
}
<% end %>
REFINE

STRUCT_TEMPLATE = <<STRUCT
/* A <%= name %> <%= doc.text if doc %><% if doc and doc.since %>
since: <%= doc.since %><% end %>*/
type <%= go_name %> struct {
  <% (ancestors||[]).each do |anc| %><%= anc %>
  <% end %>

  <% (properties||[]).each do |prop| %><% if prop.doc and prop.doc.text %>/*<%= prop.doc.text %>
  <% end %><%= prop.go_name %> <%= prop.go_type %> `xml:"<%= prop.name %><%= prop.attribute? ? ",attr" : "" %><%= prop.optional? ? ",omitempty" : "" %>"`
  <% end %>
}

STRUCT

COMMON_GO_CAPS.keys.each do |vl|
  ActiveSupport::Inflector.inflections do |inf|
    inf.acronym vl
  end
end

class SimpleType
  attr_accessor :type, :min_length, :max_length, :pattern

  def initialize(*args)
    @node = args.first
    @node.elements.each(&method(:parse_element))
  end

  def parse_element(el)
    case el.name
    when "restriction"
      @type = el["base"]
      el.elements.each(&method(:parse_restrictions))
    when "annotation"
      # skipping docs for now
    end
  end

  def parse_restrictions(el)
    case el.name
    when "minLength"
      @min_length = el["value"]
    when "pattern"
      @pattern = el["value"]
    end
  end

  def name
    @node["name"]
  end

  def to_s
    self.name
  end

  def go_type
    mapped = TYPE_MAPPING[self.type]
    return mapped if mapped
    self.type
  end

  def go_name
    self.name.classify
  end

  def to_go
    templ = ERB.new(REFINE_TEMPLATE)
    templ.run(binding)
  end

  def validatable?
    @min_length || @max_length || @pattern
  end
end

class TypeDocs
  attr_accessor :text, :since, :modifiable

  def modifiable?
    !!@modifiable
  end
end

class ComplexType
  attr_accessor :doc, :content_type, :properties, :ancestors

  def initialize(*args)
    @parent, @node = args[0], args[1]
    @node.elements.each(&method(:parse_element))
  end

  def parse_element(el)
    case el.name
    when "annotation"
      # check for doc comments
      el.elements.each(&method(:parse_annotation))
    when "element"
      (@properties||=[]) << Property.new(nil, el, false)
    when "sequence"
      el.elements.each_with_index(&method(:parse_sequence))
    when "attribute"
      (@properties||=[]) << Property.new(nil, el, true)
    when "complexContent"
      el.elements.each(&method(:parse_complex_content))
    else
      puts "unknown element: #{el.inspect}"
    end
  end

  def parse_sequence(el, i)
    case el.name
    when "element"
      (@properties||=[]) << Property.new(i, el, false)
    when "attribute"
      (@properties||=[]) << Property.new(i, el, true)
    when "annotation"
      el.elements.each(&method(:parse_annotation))
    when "sequence"
      el.elements.each_with_index(&method(:parse_sequence))
    when "complexContent"
      el.elements.each(&method(:parse_complex_content))
    end
  end

  def parse_complex_content(el)
    case el.name
    when "extension"
      (@ancestors||=[]) << el["base"]
      el.elements.each(&method(:parse_element))
    else
      puts "unknown element #{el.inspect}"
    end
  end

  def parse_annotation(el)
    case el.name
    when "documentation"
      self.parse_documentation(el)
    when "appinfo"
      self.parse_appinfo(el)
    end
  end

  def parse_documentation(at)
    case at["source"]
    when "since"
      (@doc||=TypeDocs.new).since = at.text
    when "modifiable"
      (@doc||=TypeDocs.new).modifiable = at.text
    else
      # only if the docs are english, we're interested
      if at["xml:lang"] == "en" or at.attributes.empty?
        (@doc||=TypeDocs.new).text = at.text
      else
        puts "unknown element: #{at.inspect}"
      end
    end
  end

  def parse_appinfo(apinf)
    apinf.elements.each do |el|
      if el.name == "content-type"
        @content_type = el.text
      end
    end
  end

  def name
    @node["name"]
  end

  def go_name
    self.name.classify
  end

  def type
    @node["type"]
  end


  def to_s
    self.name
  end

  def to_go
    templ = ERB.new(STRUCT_TEMPLATE)
    templ.run(binding)
  end

end

class Property
  attr_accessor :ordinal, :doc, :is_attribute

  def initialize(ord, node, iattr)
    @ordinal, @node, @is_attribute = ord, node, !!iattr
  end

  def parse_element(el)
    case el.name
    when "annotation"
      el.elements.each do |ann|
        if ann.name == "documentation"
          parse_documentation(ann)
        end
      end
    else
      puts "unknown element: #{el.inspect}"
    end
  end
  def parse_documentation(at)
    case at["source"]
    when "since"
      (@doc||=TypeDocs.new).since = at.text
    when "modifiable"
      (@doc||=TypeDocs.new).modifiable = at.text
    else
      # only if the docs are english, we're interested
      if at["xml:lang"] == "en" or at.attributes.empty?
        (@doc||=TypeDocs.new).text = at.text
      else
        puts "unknown element: #{at.inspect}"
      end
    end
  end

  def required?
    @node["use"] == "required"
  end

  def optional?
    !self.required?
  end

  def attribute?
    @is_attribute
  end

  def type
    @node["type"]||@node["ref"].gsub(/[^:]+:/, "")
  end

  def name
    @node["name"]||@node["ref"].gsub(/[^:]+:/, "")
  end

  def go_type
    mapped = TYPE_MAPPING[self.type]
    return mapped if mapped
    self.type.gsub(/[^:]+:/, "")
  end

  def go_name
    self.name.classify
  end

  def to_s
    "#{self.name} -> #{self.type}"
  end
end

class SchemaReader
  attr_accessor :path, :types, :included_schemas, :path_parts

  def initialize(*args)
    @path_parts = args
    @path = File.join(SCHEMA_PATH, *args)
    puts "reading #{@path}"
    @types = []
    @included_schemas = { args.last => self }

    schema = Nokogiri(File.read(@path))
    schema.root.elements.each(&method(:parse_element))
  end

  def parse_element(el)
    case el.name
    when "complexType"
      @types << ComplexType.new(self, el)
    when "simpleType"
      @types << SimpleType.new(el)
    when "element"
      # in java this seems to be used to generate factory methods
      # luckily this isn't java
    when "include"
      loc = el["schemaLocation"]
      unless @included_schemas.has_key? loc
        path_parts = @path_parts.dup
        path_parts[path_parts.size-1] = loc
        rdr = SchemaReader.new(*path_parts)
        # flatten and lift the included schemas, so lookup is quick and easy
        @included_schemas.merge! rdr.included_schemas
      end
    when "annotation"
      #puts "skipping annotation at top level"
    when "attribute"
      # puts "skipping attribute at top level"
    else
      puts "unknown type #{el.name}"
    end
  end

  def has?(tpe)
    @types.any? do |tt|
      tt.name == tpe.to_s
    end
  end

  def size
    @types.size
  end
end


if $0 == __FILE__
  types = []

  # parse the schemas
  %w(base error service session vchs).each do |nm|
    rdr = SchemaReader.new("vcloudair56", "#{nm}.xsd")
    #puts "collected #{rdr.size} types"
    #puts rdr.types
    types.concat rdr.types
    #puts "reader has ServiceType: #{rdr.has?(:ServiceType)}"
    #puts "included schemas: #{rdr.included_schemas.keys}"
  end

  types.each do |tpe|
    #puts "#{tpe.name} has #{(tpe.properties||[]).size} properties and #{(tpe.ancestors||[]).size} ancestors"
    tpe.to_go
  end

  types.clear

  {
    "common"=>%w(simpleTypes complexTypes resource Meta),
    "sc"=>%w(binding instance serviceplan),
    "user"=> %w(User),
    "" => %w(billableRates error metering)
  }.each do |k, v|
    v.each do |nm|
      rdr = k ? SchemaReader.new("vcloudair57", k, "#{nm}.xsd") : SchemaReader.new("vcloudair57", "#{nm}.xsd")
      types.concat rdr.types
    end
  end

  types.each do |tpe|
    tpe.to_go
  end

end
